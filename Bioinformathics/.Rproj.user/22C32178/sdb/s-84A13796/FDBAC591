{
    "contents" : "## This function can be used to retrieve TAIR GO annotation and \n## make a gene2GO mapping\n## make a GO2genes mapping\nget.GO.TAIR.annotation <- function(db='ALL', gene2GOs=TRUE, GO2genes=FALSE){\n  #Loading libraries\n  suppressPackageStartupMessages(library(org.At.tair.db))\n  \n  # If loop checking db input to load correct database\n  if (db == 'ALL'){\n    db = org.At.tairGO2ALLTAIRS\n  }else if (db == 'TAIR10'){\n    db = org.At.tairGO # database for TAIR10\n  }\n  print('Retrieving from database')\n  print(db)\n  # Output toggle\n  g2GOs = gene2GOs\n  GO2gs = GO2genes\n  \n  # Getting all the gene to GO annotations\n  GO.annotations = as.list(db)\n  GO2genes = vector(mode = \"list\", length(names(GO.annotations)))\n  names(GO2genes) = names(GO.annotations)\n  for (i in 1:length(names(GO.annotations))){\n    GO2genes[[i]] = unique(as.vector(GO.annotations[[i]]))\n  }\n  print(paste0('Number of GOs: ',length(names(GO2genes))))\n  \n  # use goseq function to \"switch\" genes and categories:\n  gene2GOs = goseq:::reversemapping(GO2genes)\n  print(paste0('Number of Genes: ',length(names(gene2GOs))))\n  \n  if (g2GOs == TRUE && GO2gs == FALSE){\n    return(gene2GOs)\n  }else if (GO2gs == TRUE && g2GOs == FALSE){\n    return(GO2genes)\n  }\n}\n\n## goseq enrichment which can be performed on a vector of colnames of genes and\n## values 0 for not significant and 1 for significant\n## Also provide the gene length\n## Also provide a gene2GO map\ngoseq.enrichment <- function(goseq_gene_vector, gene_length, gene2GOs){\n  #Loading libraries\n  suppressPackageStartupMessages(library(goseq))\n  \n  # Calculating Probability Weighting Factor (pwf) based on length of the gene\n  pwf=nullp(goseq_gene_vector, bias.data=gene_length)\n  \n  # Map all genes to GO using pwf\n  GO.wall=goseq(pwf,gene2cat=gene2GOs)\n  \n  #GO.CC=goseq(pwf,gene2cat=gene2GOs,test.cats=c(\"GO:CC\"))\n  \n  # enrichment analyses on the GO terms\n  enriched.GO=GO.wall$category[p.adjust(GO.wall$over_represented_pvalue,\n                                        method=\"BH\")<.05]\n  \n  # Make data.frame of enriched.GO incase output is 0\n  enriched.GO=as.data.frame(enriched.GO)\n  \n  # Defining output class\n  setClass(Class=\"goseq_output\",\n           representation(\n             pwf=\"data.frame\",\n             GO.wall=\"data.frame\",\n             enriched.GO=\"data.frame\"\n           )\n  )\n  \n  # Creating and returning the output class\n  return(new(\"goseq_output\",\n             pwf=pwf,\n             GO.wall=GO.wall,\n             enriched.GO=enriched.GO))\n}\n\n## topGO enrichment which can be performed on a vector of colnames of genes and\n##  values 0 for not significant and 1 for significant\n## Also provide a gene2GO map\ntopGO.enrichment <- function(goseq_gene_vector, gene2GOs, graphs=FALSE,\n                             numbertoplot=5, ontologylist, workingdir=getwd(), outputdir){\n  \n  ## Directory where will be worked in\n  dir.create(outputdir, recursive = TRUE)\n  setwd(outputdir)\n  \n  # Loading libraries\n  suppressPackageStartupMessages(library(topGO))\n  suppressPackageStartupMessages(library(Rgraphviz))\n  \n  ## internal function to get significant genes\n  select.DE.genes <- function(allScore) {\n    return(allScore > 0) \n  }\n  \n  # Check if list that is given contains valid ontology's\n  # if not a warning will be raisen and function stops\n  for (element in ontologylist){\n    if (element != 'BP' & element != 'MF' & element != 'CC'){\n      warning('Incorrect ontology given!!\\nOptions are: \"BP\",\"MF\" or \"CC\"')\n      break\n    }\n  }\n  \n  # For each ontology this will be performed\n  for (element in ontologylist){\n    \n    # Print which ontology will be used\n    print(paste0('Starting enrichment on ',element))\n\n    # Make GOdata object \n    GOdata <- new(\"topGOdata\", ontology = element, allGenes = goseq_gene_vector,\n                  geneSel = select.DE.genes, annot = annFUN.gene2GO, gene2GO = gene2GOs)\n    \n    # Printing the size of the complete graph\n    print(graph(GOdata))\n    \n    # Table of all GO hits\n    GO.hits = termStat(GOdata)\n    GO.hits = GO.hits[order(GO.hits$Significant, decreasing = TRUE),]\n    \n    print(paste0('Performing enrichment analyses on ontology: ',element))\n    # Classic Fisher test\n    test.stat <- new(\"classicCount\", testStatistic = GOFisherTest, name = \"Fisher test\")\n    resultFisher <- getSigGroups(GOdata, test.stat)\n    \n    # Weighted test on the GO \n    test.stat <- new(\"weightCount\", testStatistic = GOFisherTest, name = \"Fisher test\", sigRatio = \"ratio\")\n    resultWeight <- getSigGroups(GOdata, test.stat)\n    \n    # Saving getwd and making output directory\n    print('Output Directory:')\n    print(paste0(outputdir,'/',element))\n    dir.create(paste0(outputdir,'/',element), recursive = TRUE)\n    outputelement = paste0(outputdir,'/',element)\n    setwd(outputelement)\n    \n    # if loop if graphs need to be made or not\n    if (graphs == TRUE){\n      print(paste0('Making graphs of ontology: ',element))\n      # Print graphs in pdf to disc of all the diffecrent calculations\n      printGraph(GOdata, resultFisher, firstSigNodes = numbertoplot, fn.prefix = \"Fisher_GO\", useInfo = \"all\", pdfSW = TRUE)\n      printGraph(GOdata, resultWeight, firstSigNodes = numbertoplot, fn.prefix = \"Weighted_GO\", useInfo = \"all\", pdfSW = TRUE)\n    }\n    \n    print(paste0('Make result table of ontology: ',element))\n    # Making result table and saving it to disc\n    allRes <- GenTable(GOdata, Fisher = resultFisher, Fisher_weight = resultWeight,\n                       orderBy = \"Fisher\", ranksOf = \"Fisher\", numChar = 200, topNodes = length(resultFisher@score))\n    \n    # Reduce results to GO terms passing Benjamini-Hochberg multiple hypothesis corrected pval <= 0.05, FDR <= 5%\n    # On the Fisher exact test values\n    allRes$BH = p.adjust(allRes[,\"Fisher\"],method=\"BH\")\n    \n    # Saving the total result table to disc\n    write.table(allRes, file='allresultGO.txt', sep='\\t', row.names=FALSE)\n    \n    # Sort only FDR 0.05 GO terms\n    allRes.bh <- allRes[allRes$BH <= 0.05,]\n    write.table(allRes.bh, file='allresultGO_Benjamini_Hochberg.txt', sep='\\t', row.names=FALSE)\n\n    # resetting working directory\n    setwd(outputdir)\n  }\n  # re-resetting working directory\n  setwd(workingdir)\n  print('##########################')\n  print('topGO enrichment Completed')\n  print('##########################')\n}\n\n# Function that loads the hittable output from the HTseq_counting.py to R\nload.htseqoutput <- function(filename){\n  # Load hittable file\n  table.summary = read.table(file=filename, sep='\\t', header=TRUE, stringsAsFactors=FALSE, row.names = 1)\n  # Sort headers on name\n  table.summary = table.summary[,order(colnames(table.summary))]\n  \n  # Defined SpecialNames in the hittable and remove them\n  RemoveSpecialNames <- c( \"no_feature\", \"ambiguous\",\n                           \"too_low_aQual\", \"not_aligned\",\n                           \"alignment_not_unique\" )\n  table.summary = table.summary[setdiff(rownames(table.summary),RemoveSpecialNames),]\n  return(table.summary)\n}\n\n# Function to plot all the pairwise combinations of\n# a data.frame and save them as pdf in workding dir\nplot_all_pairwise_combinations <- function(table.summary, outputdir=getwd()){\n  \n  # Saving workingdirectory\n  oldwd=getwd()\n  \n  # Setting output directory\n  setwd(outputdir)\n  \n  # Making pdf file\n  pdf(file='Pairwise_scatterplots.pdf')\n  \n  # For loop that will do all the pairwise combinations\n  for (i in 1:length(colnames(table.summary))){\n    if (i == length(colnames(table.summary))){\n      y=1\n    }else{\n      y=i+1\n    }\n    plot(table.summary[,i],table.summary[,y], xlab=colnames(table.summary)[i],\n         ylab=colnames(table.summary)[y],\n         main=paste0(\"Pairwise comparison: \",\n                     colnames(table.summary)[i],' vs ',colnames(table.summary)[y]))\n  }\n  dev.off()\n  setwd(oldwd)\n}\n\n# Will create a sample vs sample heatmap and a top 30 genes heatmap\n# from a DESeq2 object that is normalized\nHeatmap_dds <- function(DESeq2_object, outputdir){\n  \n  # Saving workingdirectory\n  oldwd=getwd()\n  \n  # Setting output directory\n  setwd(outputdir)\n  \n  # Calc distance matrix\n  dist_dds <- dist(t(assay(dds)))\n  mat <- as.matrix(dist_dds)\n  \n  # Perform clustering on the distance (log) data\n  hc <- hclust(dist_dds)\n  \n  suppressPackageStartupMessages(library(\"RColorBrewer\"))\n  suppressPackageStartupMessages(library(\"gplots\"))\n  select <- order(rowMeans(counts(dds,normalized=TRUE)),decreasing=TRUE)[1:30]\n  hmcol <- colorRampPalette(brewer.pal(9,\"GnBu\"))(100)\n  \n  # Save heatmap counts top 30\n  pdf(file = 'heatmap_Top_30_counts.pdf')\n  heatmap.2(counts(dds,normalized=TRUE)[select,], col = hmcol,\n            Rowv = FALSE, Colv = FALSE, scale=\"none\",\n            dendrogram=\"none\", trace=\"none\", margin=c(10,6))\n  dev.off()\n  \n  # Make sample vs sample heatmap\n  pdf(file = 'heatmap_sample_vs_sample.pdf')\n  heatmap.2(mat, Rowv=as.dendrogram(hc),\n            symm=TRUE, trace=\"none\",\n            col = rev(hmcol), margin=c(13, 13))\n  dev.off()\n  setwd(oldwd)\n}\n\n# Function to make the result output table of all types\n# Same as paper\nmake_result_table <- function(reference_gene_names, Gene_types_Class,\n                              significant_result_DEseq2_1, significant_result_DEseq2_2){\n  \n  # Making data.frame/result_table\n  result_table = data.frame('Features' = c('Total genes',\n                                           'Dehydration response',\n                                           'Memory genes',\n                                           '++',\n                                           '--',\n                                           '+-',\n                                           '-+',\n                                           'Non_memory genes',\n                                           '+/=',\n                                           '-/=',\n                                           'Late-response genes',\n                                           '=/+',\n                                           '=/-'),\n                            'Total' = c(length(reference_gene_names),\n                                        nrow(significant_result_DEseq2_1),\n                                        nrow(Gene_types_Class@Memory_genes),\n                                        nrow(Gene_types_Class@plus_plus),\n                                        nrow(Gene_types_Class@min_min),\n                                        nrow(Gene_types_Class@plus_min),\n                                        nrow(Gene_types_Class@min_plus),\n                                        \"\",\n                                        nrow(Gene_types_Class@None_plus_equal),\n                                        nrow(Gene_types_Class@None_min_equal),\n                                        \"\",\n                                        nrow(Gene_types_Class@Late_equal_plus),\n                                        nrow(Gene_types_Class@Late_equal_min)\n                            ),\n                            'up' = c('',nrow(significant_result_DEseq2_1[significant_result_DEseq2_2$log2FoldChange >= 1,]),\n                                     sum(nrow(Gene_types_Class@plus_plus),nrow(Gene_types_Class@plus_min)),rep('',10)),\n                            'down' = c('',nrow(significant_result_DEseq2_1[significant_result_DEseq2_2$log2FoldChange <= -1,]),\n                                       sum(nrow(Gene_types_Class@min_min),nrow(Gene_types_Class@min_plus)),rep('',10)))\n  return(result_table)\n}\n\n# This function will produce a vector that can be used to perform GO enrichment\n# Input: reference_gene_names list; a dataframe with significant results (data);\n#        colname to match with reference genes list\n# Output: New vector file that can be used for GO enrichment\nproduce.gene.bin.sig.vector <- function(reference_gene_names, data, colname=\"Genes\"){\n  diffs = setdiff(reference_gene_names, data[,colname])\n  diffs_pp = c(diffs, data[,colname])\n  new_vector = c(rep(0,length(diffs)),rep(1,length(data[,colname])))\n  names(new_vector) = diffs_pp\n  return(new_vector)\n}\n\n# Will identify gene types using 4 input DESeq2 objects\n# Inputs: 4 DESeq2 class objects of 2 pairs of both pairwise comparisons and\n#         from the same pairwise comparisons also the same data but then only\n#         the significant;\n# Output: A new class object containing the memory genes, all types and grouping in \n#         dataframes\nIdentify.gene.types.HTseq <- function(result_DEseq2_1, result_DESeq2_2, \n                                significant_result_DEseq2_1, significant_result_DEseq2_2){\n  \n  # Renaming inputs\n  res_W_S1 = result_DEseq2_1\n  res_S1_S3 = result_DESeq2_2\n  res_W_S1_padj = significant_result_DEseq2_1\n  res_S1_S3_padj = significant_result_DEseq2_2\n  \n  # Get not significant genes W_S1\n  res_W_S1_notsig = res_W_S1[setdiff(rownames(res_W_S1), rownames(res_W_S1_padj)),]\n  \n  # Get not significant genes S1_S3\n  res_S1_S3_notsig = res_S1_S3[setdiff(rownames(res_S1_S3), rownames(res_S1_S3_padj)),]\n  \n  # Make extra column for the Genes by copying the row.names\n  res_W_S1_notsig$Genes = row.names(res_W_S1_notsig)\n  res_S1_S3_notsig$Genes = row.names(res_S1_S3_notsig)\n  res_W_S1_padj$Genes = row.names(res_W_S1_padj)\n  res_S1_S3_padj$Genes = row.names(res_S1_S3_padj)\n  \n  # Merging to get total table with all overlapping late respons genes\n  Late_response_genes = merge(as.data.frame(res_W_S1_notsig), as.data.frame(res_S1_S3_padj), by = \"Genes\")\n  Late_equal_min = Late_response_genes[Late_response_genes$log2FoldChange.y <= 0,]\n  Late_equal_plus = Late_response_genes[Late_response_genes$log2FoldChange.y >= 0,]\n  \n  # Merging to get total table with all overlapping none memory genes\n  None_memory_genes = merge(as.data.frame(res_W_S1_padj), as.data.frame(res_S1_S3_notsig), by = \"Genes\")\n  None_min_equal = None_memory_genes[None_memory_genes$log2FoldChange.x <= 0,]\n  None_plus_equal = None_memory_genes[None_memory_genes$log2FoldChange.x >= 0,]\n  \n  # Merging to get total table with all overlapping significant genes (Memory Genes)\n  Memory_genes = merge(as.data.frame(res_W_S1_padj), as.data.frame(res_S1_S3_padj), by = \"Genes\")\n  \n  # Making seperate tables of the the different types of memory genes\n  plus_plus = Memory_genes[Memory_genes$log2FoldChange.x >= 0 & Memory_genes$log2FoldChange.y >= 0,]\n  min_min = Memory_genes[Memory_genes$log2FoldChange.x <= 0 & Memory_genes$log2FoldChange.y <= 0,]\n  plus_min = Memory_genes[Memory_genes$log2FoldChange.x >= 0 & Memory_genes$log2FoldChange.y <= 0,]\n  min_plus = Memory_genes[Memory_genes$log2FoldChange.x <= 0 & Memory_genes$log2FoldChange.y >= 0,]\n  up_regulated = sum(nrow(plus_plus),nrow(plus_min))\n  down_regulated = sum(nrow(min_min),nrow(min_plus))\n  \n  # Making a grouping file for the types of memory genes\n  Grouping = cbind(plus_plus$Genes, \"[+/+]\")\n  Grouping = rbind(Grouping, cbind(min_min$Genes, \"[-/-]\"))\n  Grouping = rbind(Grouping, cbind(plus_min$Genes, \"[+/-]\"))\n  Grouping = rbind(Grouping, cbind(min_plus$Genes, \"[-/+]\"))\n  Grouping = as.data.frame(Grouping)\n  colnames(Grouping) = c(\"Genes\",\"Type\")\n  \n  # Make data frame by merging the memory genes and the type of memory genes data frames\n  Memory_genes = merge(x = Memory_genes, y = Grouping, by = \"Genes\")\n  \n  # Defining output class\n  setClass(Class=\"Gene_types\",\n           representation(\n             Memory_genes=\"data.frame\",\n             plus_plus=\"data.frame\",\n             min_min=\"data.frame\",\n             plus_min=\"data.frame\",\n             min_plus=\"data.frame\",\n             Late_equal_min=\"data.frame\",\n             Late_equal_plus=\"data.frame\",\n             None_min_equal=\"data.frame\",\n             None_plus_equal=\"data.frame\",\n             Grouping=\"data.frame\",\n             Late_response_genes=\"data.frame\"\n           )\n  )\n  \n  # Creating and returning the output class\n  return(new(\"Gene_types\",\n             Memory_genes=Memory_genes,\n             plus_plus=plus_plus,\n             min_min=min_min,\n             plus_min=plus_min,\n             min_plus=min_plus,\n             Late_equal_min=Late_equal_min,\n             Late_equal_plus=Late_equal_plus,\n             None_min_equal=None_min_equal,\n             None_plus_equal=None_plus_equal,\n             Grouping=Grouping,\n             Late_response_genes=Late_response_genes)\n  )\n}\n\n# Will identify gene types using cummeRbund object as input\n# Inputs: 1 cummeRbund objects and 4 names to make comparison,\n#         will be sample1 vs sample2 and sample3 vs sample4\n# Output: A new class object containing the memory genes, all types and grouping in \n#         dataframes\nIdentify.gene.types.cummeRbund <- function(cummeRbund_object, sample1, sample2, sample3, sample4){\n  \n  # Change colnames\n  colnames(cummeRbund_object)[grep(\"log2_fold_change\",colnames(cummeRbund_object))]=\"log2FoldChange\"\n  colnames(cummeRbund_object)[grep(\"gene_id\",colnames(cummeRbund_object))]=\"Genes\"\n  \n  # Extracting W_vs_S1 and S1_vs_S3 from the ouptut\n  W_vs_S1_genes = cummeRbund_object[cummeRbund_object$sample_1 == sample1 & cummeRbund_object$sample_2 == sample2,]\n  S1_vs_S3_genes = cummeRbund_object[cummeRbund_object$sample_1 == sample3 & cummeRbund_object$sample_2 == sample4,]\n  \n  # Extract significant genes per comparison\n  W_vs_S1_genes_sig <- subset(W_vs_S1_genes, (significant == 'yes'))\n  W_vs_S1_genes_sig <- subset(W_vs_S1_genes_sig, (abs(log2FoldChange) >= 1))\n  # 25% quantile cutoff\n  W_vs_S1_genes_sig <- W_vs_S1_genes_sig[W_vs_S1_genes_sig$value_1 > quantile(W_vs_S1_genes_sig$value_1, .25) |\n                                           W_vs_S1_genes_sig$value_2 > quantile(W_vs_S1_genes_sig$value_2, .25),]\n  S1_vs_S3_genes_sig <- subset(S1_vs_S3_genes, (significant == 'yes'))\n  # 25% quantile cutoff\n  S1_vs_S3_genes_sig <- subset(S1_vs_S3_genes_sig, (abs(log2FoldChange) >= 1))\n  S1_vs_S3_genes_sig <- S1_vs_S3_genes_sig[S1_vs_S3_genes_sig$value_1 > quantile(S1_vs_S3_genes_sig$value_1, .25) |\n                                             S1_vs_S3_genes_sig$value_2 > quantile(S1_vs_S3_genes_sig$value_2, .25),]\n  \n  #Non-significant genes in q1-W and q2-S3\n  rownames(W_vs_S1_genes_sig) = W_vs_S1_genes_sig$Genes\n  rownames(W_vs_S1_genes) = W_vs_S1_genes$Genes\n  W_vs_S1_genes_notsig = W_vs_S1_genes[setdiff(rownames(W_vs_S1_genes), rownames(W_vs_S1_genes_sig)),]\n  \n  #Non-significant genes in q2-S1 and q3-S3\n  rownames(S1_vs_S3_genes_sig) = S1_vs_S3_genes_sig$Genes\n  rownames(S1_vs_S3_genes) = S1_vs_S3_genes$Genes\n  S1_vs_S3_genes_notsig = S1_vs_S3_genes[setdiff(rownames(S1_vs_S3_genes), rownames(S1_vs_S3_genes_sig)),]\n  \n  # Getting all the memory genes\n  memory_genes = merge(W_vs_S1_genes_sig, S1_vs_S3_genes_sig, by = \"Genes\" )\n  \n  #Producing separate tables of the different types of memory genes\n  plus_plus = memory_genes[memory_genes$log2FoldChange.x >= 1 & memory_genes$log2FoldChange.y >= 1, ]\n  minus_minus = memory_genes[memory_genes$log2FoldChange.x <= 1 & memory_genes$log2FoldChange.y <= 1, ]\n  plus_minus = memory_genes[memory_genes$log2FoldChange.x >= 1 & memory_genes$log2FoldChange.y <= 1, ]\n  minus_plus = memory_genes[memory_genes$log2FoldChange.x <= 1 & memory_genes$log2FoldChange.y >= 1, ]\n  \n  #merging to get total table with late response genes\n  late_response_genes = merge(W_vs_S1_genes_notsig, S1_vs_S3_genes_sig, by = \"Genes\")\n  late_equal_plus = late_response_genes[late_response_genes$log2FoldChange.y >= 0,]\n  late_equal_minus = late_response_genes[late_response_genes$log2FoldChange.y <= 0,]\n  \n  # Merging to obtain all Non-memory genes\n  Non_memory_genes = merge(W_vs_S1_genes_sig, S1_vs_S3_genes_notsig, by = \"Genes\")\n  plus_equal = Non_memory_genes[Non_memory_genes$log2FoldChange.x >= 0,]\n  minus_equal = Non_memory_genes[Non_memory_genes$log2FoldChange.x <= 0,]\n  \n  # Making a grouping file for the types of memory genes\n  Grouping = cbind(plus_plus$Genes, \"[+/+]\")\n  Grouping = rbind(Grouping, cbind(minus_minus$Genes, \"[-/-]\"))\n  Grouping = rbind(Grouping, cbind(plus_minus$Genes, \"[+/-]\"))\n  Grouping = rbind(Grouping, cbind(minus_plus$Genes, \"[-/+]\"))\n  Grouping = as.data.frame(Grouping)\n  colnames(Grouping) = c(\"Genes\",\"Type\")\n  \n  # Make data frame by merging the memory genes and the type of memory genes data frames\n  memory_genes = merge(x = memory_genes, y = Grouping, by = \"Genes\")\n  \n  # Defining output class\n  setClass(Class=\"Gene_types\",\n           representation(\n             Memory_genes=\"data.frame\",\n             plus_plus=\"data.frame\",\n             min_min=\"data.frame\",\n             plus_min=\"data.frame\",\n             min_plus=\"data.frame\",\n             Late_equal_min=\"data.frame\",\n             Late_equal_plus=\"data.frame\",\n             None_min_equal=\"data.frame\",\n             None_plus_equal=\"data.frame\",\n             Grouping=\"data.frame\",\n             Comparison_sig_genes_1=\"data.frame\",\n             Comparison_sig_genes_2=\"data.frame\"\n           )\n  )\n  \n  # Creating and returning the output class\n  Gene_types = new(\"Gene_types\",\n                   Memory_genes=memory_genes,\n                   plus_plus=plus_plus,\n                   min_min=minus_minus,\n                   plus_min=plus_minus,\n                   min_plus=minus_plus,\n                   Late_equal_min=late_equal_minus,\n                   Late_equal_plus=late_equal_plus,\n                   None_min_equal=minus_equal,\n                   None_plus_equal=plus_equal,\n                   Grouping=Grouping,\n                   Comparison_sig_genes_1=W_vs_S1_genes_sig,\n                   Comparison_sig_genes_2=S1_vs_S3_genes_sig)\n  return(Gene_types)\n}\n",
    "created" : 1418213465623.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1282020654",
    "id" : "FDBAC591",
    "lastKnownWriteTime" : 1418213410,
    "path" : "D:/OneDrive/Advanced bioinf/project/Norm_clust_GO/functions.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}